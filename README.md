# C++ NEURAL NETWORK FROM SCRATCH - COMPLETE BEGINNER'S GUIDE

## ğŸ“š TABLE OF CONTENTS
1. [Project Overview](#project-overview)
2. [What is CMake?](#what-is-cmake)
3. [Project Structure](#project-structure)
4. [How to Build and Run](#how-to-build-and-run)
5. [Understanding Matrix Operations](#understanding-matrix-operations)
6. [Memory Management (Stack vs Heap)](#memory-management)
7. [How Neural Networks Use Matrices](#neural-networks)
8. [Step-by-Step Compilation Process](#compilation-process)

---

## ğŸ¯ PROJECT OVERVIEW

This project demonstrates how to build a neural network library in C++ from scratch, focusing on:
- Matrix operations (addition, multiplication, etc.)
- Memory management (stack vs heap)
- CMake build system
- How matrices work in neural networks

---

## ğŸ”§ WHAT IS CMAKE?

### What is CMake?
CMake is a **build system generator**. It doesn't compile your code directly. Instead, it:
1. Reads your project configuration (CMakeLists.txt)
2. Generates build files (Makefiles on Linux)
3. These build files are used by compilers (g++, clang)

### Why use CMake?
- **Cross-platform**: Works on Linux, Windows, macOS
- **Dependency management**: Handles include paths, libraries
- **Scalability**: Easy to manage large projects
- **Modern**: Standard in C++ projects

### CMake Workflow:
```
Source Code (.cpp, .h)
        â†“
   CMakeLists.txt  â† You write this configuration
        â†“
   cmake ..        â† Generates Makefiles
        â†“
   make            â† Compiles the code
        â†“
   Executable      â† Your program!
```

---

## ğŸ“ PROJECT STRUCTURE

```
NNFROMSCRATCH/
â”‚
â”œâ”€â”€ CMakeLists.txt          # Build configuration file
â”œâ”€â”€ build.sh                # Automated build script
â”œâ”€â”€ README.md               # This file
â”‚
â”œâ”€â”€ include/
â”‚   â””â”€â”€ nn/
â”‚       â””â”€â”€ matrix.h        # Matrix class declaration (header)
â”‚
â”œâ”€â”€ src/
â”‚   â””â”€â”€ matrix.cpp          # Matrix class implementation
â”‚
â”œâ”€â”€ example/
â”‚   â””â”€â”€ matrix_example.cpp  # Example program demonstrating usage
â”‚
â””â”€â”€ build/                  # Generated by CMake (build artifacts)
    â”œâ”€â”€ matrix_lib.a        # Static library (after compilation)
    â””â”€â”€ matrix_example      # Executable program (after compilation)
```

### File Explanations:

**Header File (.h):**
- Contains class declarations (what exists)
- Like a "table of contents" for your code
- Gets included by other files using `#include`

**Implementation File (.cpp):**
- Contains actual code (how things work)
- Implements functions declared in header
- Gets compiled into object files

**CMakeLists.txt:**
- Configuration for CMake
- Tells CMake how to build your project

---

## ğŸš€ HOW TO BUILD AND RUN

### Method 1: Using the Build Script (Easiest)

```bash
# Make the script executable (first time only)
chmod +x build.sh

# Run the build script
./build.sh

# Run the program
./build/matrix_example
```

### Method 2: Manual CMake (Understanding Each Step)

```bash
# Step 1: Create build directory
mkdir build
cd build

# Step 2: Generate build files with CMake
cmake ..
# This reads CMakeLists.txt and creates Makefiles

# Step 3: Compile the project
make
# This runs g++ to compile your code

# Step 4: Run the executable
./matrix_example
```

### What Happens During Build?

```
cmake ..
  â†“ Reads CMakeLists.txt
  â†“ Finds source files
  â†“ Generates Makefile
  
make
  â†“ Compiles src/matrix.cpp â†’ matrix.o
  â†“ Creates static library â†’ libmatrix_lib.a
  â†“ Compiles example/matrix_example.cpp â†’ matrix_example.o
  â†“ Links everything â†’ matrix_example (executable)
```

---

## ğŸ“ UNDERSTANDING MATRIX OPERATIONS

### What is a Matrix?

A matrix is a 2D array of numbers:

```
Matrix A (2x3):
[ 1  2  3 ]
[ 4  5  6 ]
```

- **Rows**: Horizontal (2 rows)
- **Columns**: Vertical (3 columns)
- **Dimensions**: 2Ã—3 (rows Ã— columns)

### Matrix Addition

**Rule**: Matrices must have same dimensions

```
A (2x2):        B (2x2):        C = A + B:
[ 1  2 ]    +   [ 5  6 ]    =   [ 6   8 ]
[ 3  4 ]        [ 7  8 ]        [ 10  12 ]

Calculation:
C[0][0] = A[0][0] + B[0][0] = 1 + 5 = 6
C[0][1] = A[0][1] + B[0][1] = 2 + 6 = 8
C[1][0] = A[1][0] + B[1][0] = 3 + 7 = 10
C[1][1] = A[1][1] + B[1][1] = 4 + 8 = 12
```

### Matrix Multiplication

**Rule**: A columns must equal B rows

```
A (2x3):            B (3x2):            C = A Ã— B (2x2):
[ 1  2  3 ]    Ã—    [ 7  8  ]    =    [ 58  64 ]
[ 4  5  6 ]         [ 9  10 ]         [ 139 154 ]
                    [ 11 12 ]

Calculation:
C[0][0] = (1Ã—7) + (2Ã—9) + (3Ã—11) = 7 + 18 + 33 = 58
C[0][1] = (1Ã—8) + (2Ã—10) + (3Ã—12) = 8 + 20 + 36 = 64
C[1][0] = (4Ã—7) + (5Ã—9) + (6Ã—11) = 28 + 45 + 66 = 139
C[1][1] = (4Ã—8) + (5Ã—10) + (6Ã—12) = 32 + 50 + 72 = 154
```

### In Our C++ Code:

```cpp
// Create matrices
Matrix A(2, 2);
A.set(0, 0, 1.0);
A.set(0, 1, 2.0);
A.set(1, 0, 3.0);
A.set(1, 1, 4.0);

Matrix B(2, 2);
B.set(0, 0, 5.0);
B.set(0, 1, 6.0);
B.set(1, 0, 7.0);
B.set(1, 1, 8.0);

// Addition (uses operator+)
Matrix C = A + B;

// Multiplication (uses operator*)
Matrix D = A * B;

// Print results
C.print();
D.print();
```

---

## ğŸ’¾ MEMORY MANAGEMENT (STACK VS HEAP)

### Computer Memory Layout:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” High Memory Address
â”‚   Stack             â”‚ â† Local variables, function calls
â”‚   (few MB)          â”‚   Fast, auto-managed
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   â†“ Growing         â”‚
â”‚                     â”‚
â”‚   â†‘ Growing         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Heap              â”‚ â† Dynamic allocation (new/malloc)
â”‚   (GBs available)   â”‚   Slower, manual management
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Data Segment      â”‚ â† Global variables
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Code/Text         â”‚ â† Your compiled program
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ Low Memory Address
```

### Stack Allocation:

```cpp
void function() {
    Matrix m(2, 2);  // Allocated on stack
    // Automatically destroyed when function ends
}
```

**Characteristics:**
- âœ… Fast allocation/deallocation
- âœ… Automatic cleanup
- âœ… No memory leaks
- âŒ Limited size (~8MB)
- âŒ Destroyed when function exits

### Heap Allocation:

```cpp
void function() {
    Matrix* m = new Matrix(2, 2);  // Allocated on heap
    // ...
    delete m;  // MUST manually delete!
}
```

**Characteristics:**
- âœ… Large size (GBs)
- âœ… Persists beyond function scope
- âŒ Slower allocation
- âŒ Must manually delete (risk of memory leaks)

### Important: std::vector Uses Heap!

```cpp
Matrix m(100, 100);  // Matrix object on stack
// BUT the actual 10,000 doubles are on HEAP
// because Matrix uses std::vector internally!
```

**Memory layout for Matrix m(2,2):**

```
STACK:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Matrix m       â”‚ â† Object structure (~32 bytes)
â”‚ - rows: 2      â”‚
â”‚ - cols: 2      â”‚
â”‚ - data: ptr â”€â”€â”€â”¼â”€â”€â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
                      â”‚
HEAP:                 â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ std::vector data           â”‚
â”‚ [0][0] [0][1]             â”‚
â”‚ [1][0] [1][1]             â”‚
â”‚ (4 doubles = 32 bytes)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ§  HOW NEURAL NETWORKS USE MATRICES

### Neural Network Structure:

```
Input Layer    Hidden Layer    Output Layer
   (2)            (3)              (2)

   xâ‚  â”€â”€â”€â”€â”€â”€â”€â†’  hâ‚  â”€â”€â”€â”€â”€â”€â”€â†’  yâ‚
        Wâ‚          Wâ‚‚
   xâ‚‚  â”€â”€â”€â”€â”€â”€â”€â†’  hâ‚‚  â”€â”€â”€â”€â”€â”€â”€â†’  yâ‚‚
               
               hâ‚ƒ
```

### Matrix Representation:

```
Input (X):        Weight 1 (Wâ‚):      Hidden (H):
[ xâ‚  xâ‚‚ ]   Ã—    [ wâ‚â‚ wâ‚â‚‚ wâ‚â‚ƒ ]  =  [ hâ‚ hâ‚‚ hâ‚ƒ ]
                  [ wâ‚‚â‚ wâ‚‚â‚‚ wâ‚‚â‚ƒ ]

(1Ã—2)         Ã—   (2Ã—3)            =   (1Ã—3)
```

### Forward Propagation:

```cpp
// Input: 1 sample, 2 features
Matrix input(1, 2);
input.set(0, 0, 0.5);  // Feature 1
input.set(0, 1, 0.8);  // Feature 2

// Weights: 2 inputs â†’ 3 hidden neurons
Matrix weights1(2, 3);
// ... set weight values

// Matrix multiplication
Matrix hidden = input * weights1;

// Add bias
Matrix bias(1, 3);
hidden = hidden + bias;

// Apply activation function
hidden = hidden.apply([](double x) { 
    return 1.0 / (1.0 + exp(-x));  // Sigmoid
});
```

### Why Matrices?

1. **Efficient Computation**: One matrix operation replaces many loops
2. **Vectorization**: CPUs/GPUs can process matrices in parallel
3. **Clean Code**: `hidden = input * weights` is elegant
4. **Mathematical Foundation**: Neural networks are linear algebra

### Backpropagation Uses Matrices Too:

```cpp
// Gradient descent update
// weights = weights - learning_rate Ã— gradient

Matrix gradient = /* calculated from loss */;
double learning_rate = 0.01;

weights = weights - (gradient * learning_rate);
```

---

## âš™ï¸ STEP-BY-STEP COMPILATION PROCESS

### What Happens When You Compile?

```
Source Code â†’ Preprocessor â†’ Compiler â†’ Assembler â†’ Linker â†’ Executable
```

### Detailed Process:

#### 1. Preprocessing
```bash
g++ -E src/matrix.cpp -I include
```
- Expands `#include` directives
- Processes `#define` macros
- Removes comments
- Outputs: Preprocessed code

#### 2. Compilation
```bash
g++ -S src/matrix.cpp -I include
```
- Converts C++ to assembly language
- Checks syntax
- Outputs: Assembly file (.s)

#### 3. Assembly
```bash
g++ -c src/matrix.cpp -I include
```
- Converts assembly to machine code
- Creates object file
- Outputs: matrix.o

#### 4. Linking
```bash
g++ matrix.o matrix_example.o -o matrix_example
```
- Combines object files
- Resolves function calls
- Creates executable

### What CMake Does:

CMake automates all these steps:

```cmake
# CMakeLists.txt

# Create library from matrix.cpp
add_library(matrix_lib STATIC src/matrix.cpp)

# Create executable from example
add_executable(matrix_example example/matrix_example.cpp)

# Link executable with library
target_link_libraries(matrix_example matrix_lib)
```

When you run `make`, it executes:

```bash
# Compile matrix.cpp â†’ matrix.o
g++ -c -std=c++17 -I include src/matrix.cpp -o matrix.o

# Create static library
ar rcs libmatrix_lib.a matrix.o

# Compile example
g++ -c -std=c++17 -I include example/matrix_example.cpp -o matrix_example.o

# Link everything
g++ matrix_example.o libmatrix_lib.a -o matrix_example
```

---

## ğŸ“ LEARNING EXERCISES

### Exercise 1: Modify the Example
Try adding your own matrix operations to `matrix_example.cpp`:
- Create a 3Ã—3 identity matrix
- Multiply two matrices
- Calculate the transpose

### Exercise 2: Add New Features
Extend the Matrix class in `matrix.h` and `matrix.cpp`:
- Add a `determinant()` function
- Add an `inverse()` function
- Implement matrix subtraction

### Exercise 3: Build a Simple Neural Network
Create a new file `simple_nn.cpp`:
- Define input, weights, bias
- Implement forward pass
- Calculate output

---

## ğŸ› COMMON ERRORS AND SOLUTIONS

### Error: "No such file or directory"
```
fatal error: nn/matrix.h: No such file or directory
```
**Solution**: Make sure you're building from the project root and CMake knows the include path.

### Error: "undefined reference to Matrix::..."
```
undefined reference to 'Matrix::print()'
```
**Solution**: You forgot to link the library. Check `target_link_libraries` in CMakeLists.txt.

### Error: Segmentation fault
```
Segmentation fault (core dumped)
```
**Solution**: You're accessing memory incorrectly. Check array bounds and null pointers.

---

## ğŸ“– ADDITIONAL RESOURCES

### C++ Concepts:
- **Classes**: Blueprints for objects
- **Constructors**: Initialize objects
- **Operators**: Overload `+`, `*`, etc.
- **Templates**: Generic programming
- **STL**: Standard Template Library (vector, etc.)

### Neural Network Concepts:
- **Forward propagation**: Input â†’ Output
- **Backpropagation**: Calculate gradients
- **Gradient descent**: Update weights
- **Activation functions**: Sigmoid, ReLU, tanh

### Further Reading:
- CMake Documentation: https://cmake.org/documentation/
- C++ Reference: https://cppreference.com/
- Neural Networks Tutorial: http://neuralnetworksanddeeplearning.com/

---

## ğŸ‰ CONCLUSION

You now understand:
- âœ… How CMake builds C++ projects
- âœ… How matrices are stored in memory
- âœ… How to perform matrix operations
- âœ… How neural networks use matrices
- âœ… The complete compilation process

**Next Steps:**
1. Run the example program
2. Modify the code
3. Build a simple neural network
4. Experiment and learn!

Happy coding! ğŸš€
# NeuralNetworkStudy
